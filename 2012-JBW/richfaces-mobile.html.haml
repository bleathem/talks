---
layout: reveal
---

%section
  %img.splash.screen{:src => "assets/images/splash_scaled.png"}
  %img.splash.print{:src => "assets/images/splash_scaled_black.png"}
%section
  %h1 Going Mobile
  %h2.capitalize with your RichFaces Applications
  %ul.intro
    %li Brian Leathem
    %li Senior Software Engineer, Red Hat
    %li 06.28.12
  .footer
    %img.summit-logo{:src => "assets/images/summit_logo_shadow.png" }
    %img.redhat-logo{:src => "assets/images/redhat_logo_notext.png" }
  %ul.notes
    %li Welcome to the session "Going Mobile with your RichFaces Applications"
%section
  %h2 The plan
  %ul
    %li Why the Mobile Web?
    %li Why JSF?
    %li Why RichFaces?
  %div
    %img{:src => "assets/images/storm_troopers.jpg", :alt => "http://www.flickr.com/photos/jdhancock/5845280258/", :style => "clear: both"}
  %ul.notes
    %li We're here to talk about writing mobile applications with JSF and RichFaces
    %li We'll first establish that the mobile web is an <b>important</b> and <b>unavoidable</b> target in today's market
    %li Then we'll demonstrate how JSF & RichFaces can be effective tools in this space.
    %li
      Before we dive in, I'd like to get a feel from you as to how you are positioned today:
      %ol
        %li Who amongst you are currently using RichFaces for Desktop Applications?
        %li Who is unsure whether they need a mobile solution at all?
        %li Who already has a mobile strategy in place?
        %li Those of you who do already have a mobile strategy in place, how many are doing it with JSF?
%section
  %h2 Who am I?
  %ul
    %li Senior Software Engineer at Red Hat
    %li RichFaces Project Lead
    %li Represent Red Hat on the JSF 2.2 EG (JSR-344)
    %li Seam Faces module lead
  %div
    %img{:src => "assets/images/silhouette.png", :alt => "http://leslycorazon.wikispaces.com/file/detail/head-silhouette-with-question-mark.png/319199232"}
  %ul.notes
    %li I am the RichFaces project lead and I represent Red Hat on the JSF 2.2 EG
    %li If you have any question regarding Red Hat and JSF, feel free to corner me at any point throughout the summit
%section
  %section
    %h2 Why Mobile?
    %p I write desktop apps!
    %img{:src => "assets/images/old_computer.jpg", :alt => "http://www.linuk.web.id/2010/09/biografi-singkat-linus-torvalds.html"}
    %ul.notes
      %li It's not immediately obvious in many market areas that an organisation can benefit from a mobile application
      %li There a number of typical, seemingly sound arguments providing a mobile interface:
      %li
        "My Users need a desktop application!"
        %ul
          %li complex interface
          %li data entry requirements
          %li sit at their desk all day
          %li need a mouse
      %li However, despite these arguments, we have a game changer
  %section
    %h2 Smartphones!
    %img{:src => "assets/images/MartinCooper.jpg", :alt => "http://en.wikipedia.org/wiki/File:2007Computex_e21Forum-MartinCooper.jpg"}
    %ul.notes
      %li [Hold up my phone]
      %li These little devices in everyone's pocket, with enough computing power packed in them to compete with desktop PC's
      %li
        This has provided your users and customers with the means to access your data anywhere.
        %ul
          %li Not the same kind of interaction as on a desktop app
          %li Use cases may be different, but no less valid.
          %li For instance, a use case may be an inventory status, rather then data entry
      %li This is a photo of Martin Cooper (the inventor of the cell phone) holding the famous motorolla brick phone
      %li For me it's a shocking reminder of how far mobile phones have come in such a short time.
  %section
    %h2 Mobile phones are everywhere!
    %img{:src => "assets/images/mobile-chart2.png", :alt => "http://gigaom.com/2010/04/12/mary-meeker-mobile-internet-will-soon-overtake-fixed-internet/"}
    %ul.notes
      %li Mobile phones are everywhere!
      %li with greater than 1 billion mobile users today
      %li By 2014 there will be more mobile users than desktop users
      %li
        Granted these aren't all smartphone users, but
        %ul
          %li the trend is such that mobile phones are increasing in complexity, not decreasing
          %li further driving the need for mobile apps.
%section
  %section
    %h2 Choose: Native app or Mobile
    %ul
      %li Native:
      %ul
        %li Responsive
        %li Touch-specific controls
        %li Native L&F
      %li
        Web:
      %ul
        %li Common across platforms
        %li HTML 5 / CSS 3 / javascript
    %ul.notes
      %li
        Those of you who have looked at developing mobile apps know you have a choice to make between Natvie and Web applications
      %li
        Native:
        %ul
          %li has traditionally had the advantage of... [see advantages above]
          %li but there are too many platforms to be able to develop for the all
      %li
        Web:
        %ul
          %li Conversely, the mobile web is ubiquitous across platforms
          %li but traditionally doesn't offer the native advantages
      %li Then there is the hybrid approach which tries to offer the best of both worlds (See Aerogear Summit presentations)
  %section
    %h2 Choose: Native app or Mobile
    %p So how do I choose?
    %img{:src => "assets/images/damned_if_you_do.jpg", :alt => "https://devcentral.f5.com/weblogs/macvittie/archive/2008/09/10/3604.aspx"}
    %ul.notes
      %li So how do we choose?
      %li On the one hand, we have native with apparent runtime advantages, at the cost of an increased development burden
      %li On the other hand we have web apps with their ubiquitous run-time, but potential platform limitations
      %li It seems we are "damned" either way
      %li
        I love this graphic
        %ul
          %li it was on my father's coffee cup growing up
          %li when I was young it was just a funny picture
          %li but every year I understood a little more the predicament it was describing
          %li now I think of it whenever I'm faced with any unpleasant dilemma
      %li but not to worry - I have an answer for this mobile dilemma!
  %section{ :"data-state" => "alert"}
    %h1.relative{:style => "top: 180px;"} You need a mobile web app regardless!
    %ul.notes
      %li You need a mobile web app regardless!
      %li Not everyone can nor will install your native app, even if it is better
      %li For consumer-facing applications this is obvious - it's not practical to install an app for *every* store at which one shops
      %li
        I was in a hardware store recently - I wanted to by a garden hose and some related accessories
        %ul
          %li I wanted to price compare with a neighboring store
          %li On visiting with website on my mobile phone, I was prompted to install a native application - No way!
          %li Fall back to a mobile web-app that more than meeted my needs
      %li Not always the case - some mobile web apps are horrible!
      %li Let's mare sure the ones we write aren't!
%section
  %section
    %h2 Mobile Web is Ready
    %div.html5_slide
      %ul
        %li HTML 5
        %li CSS 3
        %li JavaScript
      %div.relative{:style => "float:right; top: -50px;"}
        %img{:src => "assets/images/CSS3_Logo.png"}
        %img{:src => "assets/images/HTML5_Logo_256.png", :style => "top: 100px; left: -50px"}
      %p{:style => "clear:both; top: 70px;"}
        Html 5 Web App &rarr; Native App
    %ul.notes
      %li The good news is today's mobile web is ready and well suited to deliver full featured mobile applications.
      %li With HTML 5, CSS 3, and the latest javascript API's
      %li we can access many of the phones features and compete toe-to-toe with native apps
  %section
    %h2 target = Webkit
    %a{:href => "http://gs.statcounter.com/#mobile_os-ww-monthly-201205-201205-bar"}
      %img{:src => "assets/images/mobile_os_marketshare.jpg"}
    %ul.notes
      %li We can further simplify our story by focusing on webkit based browsers.
      %li This covers the browsers that ship with the Android, iOS, blackberry and Symbian OS'es
      %li These also happen to be today's leading mobile platforms, justifying our focus on webkit browsers
      %li This focus then allows us to target the subset of HTML 4 and CSS 3 features supported on webkit
  %section
    %h2 JavaScript APIs
    %ul
      %li Geo-location
      %li Local Storage
      %li Web Sockets
      %li Canvas
      %li Drag and Drop
      %br
      %li
        %a{:href => "http://www.quirksmode.org/webkit_mobile.html"}
          bit.ly/webkit-comparison
    %ul.notes
      %li What javascript API's do we have available?
      %li There are many, but some of the most interesting ones for JSF components are listed here
      %li
        You can imagine the kind of JSF Components we can make with these API's
        %ul
          %li a location aware mapping component
          %li Data Table pagers that pre-fetch and store the data locally
          %li Push applications using web sockets to respond to server-side events - (in fact we have this one already!)
          %li Canvas driven components drawing arbitrary graphics (Dials, sliders, etc)
      %li The possibliities are seemingly litmitless
      %li Let's look at some specific things we can achieve leveraging the HTML 5, CSS 3, and javascript APIs
  %section
    %h2 Hide the Location bar
    %img.plain.relative{:src => "assets/images/kitchensink-mobile-home_scaled.png", :style => "float: right; top: -30px; left: -50px;"}
    %pre{:class => "prettyprint", :style => "font-size: 14pt; margin-top: 120px; width: 550px; margin-left: 0"}
      %code
        &nbsp;
        :escaped
          hideURLBar: function() {
              //hide the url bar on mobile devices
              setTimeout(scrollTo, 100, 0, 1)
          }
        &nbsp;
    %div.screen.relative{:style => "border: solid red 4px; margin-left: 50px; width: 450px; height: 0.8em; top: -83px"}
    %ul.notes
      %li Starting with a simple but effective example: hiding the location bar
      %li Here's a screen-shot of a mobile web-app
      %li Notice there is no location bar
      %li It doesn't "look" like a web browser
      %li Achieving this is simply a matter calling the DOM method "scrollTo", here invoked after a timeout to allow the page to load
  %section
    %h2 Orientation Detection
    %img.plain.relative{:src => "assets/images/landscape.png", :style => "float: left; left: 30px; top: 100px;"}
    %img.plain.relative{:src => "assets/images/portrait.png", :style => "float: left; left: 100px"}
    %ul.notes
      %li Another "must have" for mobile apps is orientation detection.
      %li When we have more screen real estate available, we should use it!
      %li In this trivial example, we conditionally display table columns depending on the orientation of the device.
      %li In the portrait mode, we display the id and name columns, and add the email and phone number in the landscape view
  %section
    %h2 Orientation Detection
    %img.plain.relative{:src => "assets/images/portrait_scaled.png", :style => "float: right; top: -30px; left: -50px; z-index: 30"}
    %pre{:class => "prettyprint", :style => "font-size: 14pt; margin-top: 0px; width: 550px; margin-left: 0; z-index: 10"}
      %code
        &nbsp;
        :escaped
          /* portrait screen width */
          @media screen and (max-width: 480px) {
             .portrait {
             }
             .landscape {
                display:none;
             }
          }

          /* landscape/desktop device widths */
          @media screen and (min-width: 481px) {
             .portrait {
                display:none;
             }
             .landscape {
             }
          }
        &nbsp;
    %ul.notes
      %li We achieve this with some simple CSS leveraging the max-width CSS 3 property
      %li When the with of the display is less than the value specified (480px) we hide any element wit the CSS class "landscape"
      %li We've also created the converse "portrait" css class, Although it tends to be less useful in practice.
  %section
    %h2 Hardware acceleration
    %h3.capitalize{:style => "margin-top: 60px"} Activate the GPU for compositing each page
    %pre{:class => "prettyprint", :style => "font-size: 14pt;  margin-top: 20px"}
      %code{:id => "activate_the_gpu"}
        &nbsp;
        :escaped
          .page {
            ...
            -webkit-transform: translate3d(0, 0, 0);
          }
        &nbsp;
    %ul.notes
      %li Another important feature available with CSS 3 is the transform translate3d css property
      %li We can achieve a performance boost for our mobile web apps wit this simple CSS rule
      %li When this rule is present, the browser will activate the GPU for rendering visual effects
      %li In fact the presentation you are looking at now is written in HTML 5, and uses the same CSS property to power the page transitions
      %li [Press ESC to zoom out]
      %li Again, we see seemingly limitless possibilities of what we can achieve with HTML 5.
  %section
    %h2 HTML 5 presentation
    %pre{:class => "prettyprint", :style => "font-size: 14pt;  margin-top: 100px"}
      %code
        &nbsp;
        :escaped
          <section>
            <h2>The plan</h2>
            <ul>
              <li>Why the Mobile Web?</li>
              <li>Why JSF?</li>
              <li>Why RichFaces?</li>
            </ul>
          </section>
        &nbsp;
    %ul.notes
      %li To drive the point home, here is the markup used to create one of the introductory slides of this presentation
      %li As you can see, it consists of nothing more than the HTML 5 "section" tag, and a conventional HTML unordered list
      %li The rest of the style and behaviour comes from CSS 3 and javascript
  %section
    %h2 Plethora of Frameworks
    .images.white{:style => "margin-top: 50px"}
      %table
        %tr
        %td
          %img{:src => "assets/images/frameworks/yui.png"}
        %td
          %img{:src => "assets/images/frameworks/Jquery-mobile-logo.png"}
        %td
          %img{:src => "assets/images/frameworks/sencha.png"}
      %table
        %tr
          %td
            %img{:src => "assets/images/frameworks/zepto_js.png"}
          %td
            %img{:src => "assets/images/frameworks/sproutcore.png"}
    %h2.fragment{:style => "margin-top: 50px"}
      + JSF !!
    %ul.notes
      %li There are a number of frameworks out there dedicated to simplifying this space and enabling developers to more easily and effectively write web applications.
      %li Perhaps you've already heard of some of these - all great frameworks in their own right
      %li I'm here today to convince you that JSF is a worthy candidate to be added to this list
%section
  %section
    %h2 Why JSF?
    %img.plain.relative{:src => "assets/images/question_mark.png", :style => "float:right; left: -40px"}
    %h3.capitalize{:style => "margin-top: 180px"} What do we like about JSF?
    %ul.notes
      %li What does JSF have going for it that we should to consider it for mobile use cases?
  %section
    %h2 JSF Because...
    %img.plain.relative{:src => "assets/images/java_logo.png", :style => "float:right; left: -40px"}
    %p{:style => "margin-top: 180px"} Standardized as part of Java EE
    %ul.notes
      %li The biggest plus for me with JSF is that it is a standard
      %li With multiple OSS implementations
      %li Healthy component vendor marketplace - again OSS
      %li No vendor lock-in!
  %section
    %h2 JSF Because...
    %img.plain.relative{:src => "assets/images/ajax_logo.png", :style => "float:right; left: -40px"}
    %p{:style => "margin-top: 180px"}
      Ajax is baked-in
      %br
      to the framework
    %ul.notes
      %li AJAX plays a huge roll in developing mobile web apps.
      %li With JSF 2.0, AJAX is front & center in the platform, ready for us to tap into to deliver fast and responsive applications
  %section
    %h2 JSF Because...
    %img.plain.relative{:src => "assets/images/puzzle.png", :style => "float:right; left: -40px: height: 300px"}
    %p{:style => "margin-top: 180px"}
      Component-oriented
      %br
      programming model
    %ul.notes
      %li Similarly we will rely heavily on javascript as we develop mobile web applications.
      %li But JSF components abstract away the javascript
      %li We write to a standardized component model, rather than to arbitrary javascript libraies
      %li As I'm fond of saying on behalf of the RichFaces project: "We write the javascript so you don't have to"
  %section
    %h2 JSF Because...
    %img.plain.relative{:src => "assets/images/jigsaw.png", :style => "float:right; left: -40px: height: 300px"}
    %p{:style => "margin-top: 180px"}
      Facelets:
      %br
      A powerful templating mechanism
    %ul.notes
      %li Facelets are one of the crown jewels of the JSF eco-system
      %li We have a highly expressive and compositable templating language
      %li
        %ul
          %li includes
          %li composite component
          %li fragments and compositions
      %li Keep our view code DRY
  %section
    %h2 JSF Because...
    %h3.normalcase{:style => "margin-top: 120px"}Build on our investment in JSF/RichFaces technology!
    %table.images{:style => "margin-top: 80px"}
      %tr
        %td
          %img{:src => "assets/images/group.png", :alt => "http://openclipart.org/detail/17302/groupe-by-czara1"}
        %td
          %img{:src => "assets/images/network.png", :alt => "http://openclipart.org/detail/36571/tango-network-workgroup-by-warszawianka"}
        %td
          %img{:src => "assets/images/clock.png", :alt => "http://openclipart.org/detail/48427/clock-by-palomaironique"}
        %td
          %img{:src => "assets/images/money.png", :alt => "http://openclipart.org/detail/22860/money-bag-icon-by-chovynz"}
    %ul.notes
      %li Finally, let's use JSF to leverage our existing investment of people, infrastructure, time and money in JSF and RichFaces technologies
      %li Why should we start with something altogether new if we don't have to?
%section
  %section
    %h2 Adapting JSF to be &ldquo;Mobile Ready&rdquo;
    %ul
      %li
        Responsive
        %ul.fragment
          %li Single Page programming model (via JSF AJAX)
      %br
      %li
        Touch-specific controls
        %ul.fragment
          %li CSS 3 styling
      %br
      %li
        Mobile L&F
        %ul.fragment
          %li Component libraries
    %ul.notes
      %li JSF is great, but it needs some help to be made "mobile ready"
      %li To create responsive applications, we want to make heavy use of AJAX and avoid full page loads.
      %li To achieve thos, we adopt a single page programming model, which unfortunately is not well supported by the JSF navigation system - at least not yet ;)
      %li
      %li JSF Components need to be made Touch "compatible".
      %li For instance as a rule-of-thumb the touchable area should be 1cm x 1cm.
      %li Fortunately achieving this is simply a matter of providing the right CSS skin
      %li
      %li Finally we want to achieve a mobile L&F.
      %li The responsibility here falls to us, the component providers
      %li We'll take a close look at the RichFaces mobile components shortly, but first let's see what we can do with "vanilla" JSF
  %section
    %h2 Device Detection
    %img{:src => "assets/images/iphone_ipad.jpg", :alt => "http://www.flickr.com/photos/ivyfield/4486938457/" }
    %ul.notes
      %li One key requirement is to have the ability to tailor the content to the viewing device
      %li We've seen earlier that we can use CSS techniques to tailor the display based on the screen size
      %li But this is a client-side technique and works after the content is delivered to the browser
      %li
      %li If we want to seamlessly provide both mobile and desktop applications, we need to know sooner:
      %li on the server before the content is rendered and delivered
  %section
    %h2 Device Detection
    %h3.capitalize{:style => "margin-top: 60px"} User Agent String
    %pre{:class => "prettyprint", :style => "font-size: 14pt;  margin-top: 20px"}
      %code
        &nbsp;
        :escaped
          Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.56 Safari/536.5
        &nbsp;
    %ul.notes
      %li Fortunately this is possible by inspecting the "user-agent" string which is sent from the browser with the initial request.
      %li
        Here we can see a typical user agent, and can infer some significant details from it.  For instance:
        %ul
          %li The browser claims to be Mozilla compliant (a useless claim nowadays)
          %li The OS is 64-bit linux
          %li The browser is a webkit browser
      %li What's important here is that it's obvious from this user-agent string that this is a desktop browser, and not a mobile one.
      %li The server knows this from the time of the initial request and we can react accordingly
  %section
    %h2 Device Detection
    %h3.capitalize{:style => "margin-top: 60px"} Server Side: UAgentInfo
    %pre{:class => "prettyprint", :style => "font-size: 14pt; margin-top: 20px"}
      %code
        &nbsp;
        :escaped
          public class UAgentInfo implements Serializable {
             ...
             public void initDeviceScan() {
                this.isIphone = detectIphoneOrIpod();
                this.isAndroidPhone = detectAndroidPhone();
                this.isTierTablet = detectTierTablet();
                this.isTierIphone = detectTierIphone();
                this.isTierRichCss = detectTierRichCss();
                this.isTierGenericMobile = detectTierOtherPhones();
             }
            ...
        &nbsp;
    %ul.notes
      %li Fortunately we don't have to parse the user-agent ourselves.
      %li We can leverage libraries to do this for us, like the UAgentInfo library shown here.
      %li We can use this library to determine whether the request originated from:
      %li [ go thorugh the API above ]
  %section
    %h2 Device Detection
    %h3.capitalize{:style => "margin-top: 60px"} JSF Bean: UserAgent
    %pre{:class => "prettyprint", :style => "font-size: 14pt;  margin-top: 20px"}
      %code
        &nbsp;
        :escaped
          @Model
          public class UserAgent {

             private UAgentInfo uAgentInfo;

             @PostConstruct
             public void init() {
                FacesContext context = FacesContext.getCurrentInstance();
                HttpServletRequest request = (HttpServletRequest)
                            context.getExternalContext().getRequest();
                String userAgentStr = request.getHeader("user-agent");
                String httpAccept = request.getHeader("Accept");
                uAgentInfo = new UAgentInfo(userAgentStr, httpAccept);
             }
        &nbsp;
    %ul.notes
      %li Using this library from JSF is then remarkably easy.
      %li Here we have a CDI bean that instantiates an instance of UAgentInfo and feeds it the user-agent string from the FacesContext
      %li We can then access the UAGentInfo's methods from our JSF beans, or from expression language to tailor our response accordingly
  %section
    %h2 Device Detection
    %h3.capitalize{:style => "margin-top: 60px"} URL Rewriting: ReWrite
    %pre{:class => "prettyprint", :style => "font-size: 14pt; margin-top: 20px"}
      %code
        &nbsp;
        :escaped
          public Configuration getConfiguration(final ServletContext context) {
             return ConfigurationBuilder.begin()
                .defineRule()
                .when(Direction.isInbound()
                .and(Path.matches("/").or(Path.matches("/index.jsf")))
                .and(UserAgent.isMobile())
                ).perform(Forward.to("/mobile/"));
             }
        &nbsp;
    %ul.notes
      %li In fact, in our sample applications we take this one step further and make use of URL rewriting library called "ReWrite"
      %li Rewrite has UAgentInfo built in, and we can define a simple rule to redirect mobile requests to a mobile specific page
      %li The rule here can be interpreted as:
      %li "If the requested page is the index page,and the request comes from a mbile browser, then redirect the request to a mobile specific page"
      %li Rewrite works at the servlet level, before the request even gets to JSF.
      %li This makes it transparent from a JSF perspective.
%section
  %section
    %h2 The RichFaces value add
    %img.relative{:src => "assets/images/richfaces-logo.png", :style => "float:right; left: -40px; padding: 20px"}
    %p{:style => "margin-top: 180px"} For mobile JSF apps
    %ul.notes
      %li By now we have a good idea of why we want to use JSF in our mobile web applications
      %li But why use RichFaces?
      %li What's the RichFaces value-add?
  %section
    %h2 The RichFaces Showcase
    %img.plain.relative{:src => "assets/images/showcase.png", :style => "float:right; left: -40px"}
    %ul{:style => "margin-top: 160px"}
      %li Mobile compatible components
      %li
        %a{:href => "http://showcase.richfaces.org", :target => "demo"} http://showcase.richfaces.org
    %ul.notes
      %li The most obvious answer is the UI components
      %li With RichFaces 4.1 and 4.2 we are shipping "mobile compatible" RichFaces components
      %li These are our existing components adapted to mobile environments through the inclusion of some mobile specific CSS
      %li Let's take a quick look at our showcase on a mobile browser to see some of these components in action
      %li [ demo the RichFaces mobile showcase ]
  %section
    %h2 a4j:push
    %p{:style => "width: 90%; margin: 40px auto 10px auto; text-align: left"}Facelet Source
    %pre{:class => "prettyprint", :style => "font-size: 18px; margin-top: 0px"}
      %code
        &nbsp;
        :escaped
          <a4j:push address="pushCdi"
            ondataavailable="jQuery('<li/>').text(event.rf.data)
                                            .prependTo('#messages')" />
          <ul id="messages" />
        &nbsp;
    %p{:style => "width: 90%; margin: 40px auto 10px auto; text-align: left"}Java Source
    %pre{:class => "prettyprint", :style => "font-size: 18px"}
      %code
        &nbsp;
        :escaped
          @Inject
          @Push(topic = "pushCdi")
          Event<String> pushEvent;

          public void sendMessage() {
            pushEvent.fire("My Message");
          }
        &nbsp;
    %ul.notes
      %li In addition to the UI components, RichFaces also offers a number of non-visual components
      %li In particular the a4j:push component is particularly valuable in mobile applications
      %li where we can have the mobile clients respond to server-side events
      %li Here we see some sample code demonstrating how simple the push component is to use
      %li On our facelet page, we place an a4j:push component addressing a particular topic
      %li then in our backing bean we use CDI to inject a pushEvent for the same topic
      %li finally we fire a message from the pushEven in our backing bean, and respond to that event on the client-side
      %li here we respond to the event with a javascript event listener, but we could equally-well trigger an ajax update
      %li I should also point out that CDI is not required, we also provide a non-CDI APi for working with the push component
  %section
    %h2 a4j:push in tweetstream
    %img.plain.relative{:src => "assets/images/tweetstream-phone.png", :style => "float:right; left: -40px"}
    %p{:style => "margin-top: 180px"} JBW 2011 Keynote
    %ul.notes
      %li Perhaps you remember the tweetstream demo from last year's JBoss world keynote?
      %li the tweetstream demo is a terrific example of using the RichFaces push component in a mobile JSF application
      %li we'll go through a demo of it shortly, when we get to our sample application
  %section
    %h2 Client-side validation
    %img.plain.relative{:src => "assets/images/kitchensink-mobile-validation.png", :style => "float:right; left: -40px"}
    %ul{:style => "margin-top: 160px"}
      %li Perform validation locally
    %ul.notes
      %li Another good example of the RichFaces value-add is our support for client-side bean validation
      %li We provide a javascript implementation of the Java EE bean validation spec, and validate input values before they are sent to the server
      %li This avoids a round-trip to the server, and improves the responsiveness of your mobile applications
      %li With mobile web apps, the more we can do locally, the better off we'll be
  %section
    %h2 a4j:jsFuntion
    %h3.normalcase{:style => "margin-top: 80px"} A facelet component interface to the JSF AJAX API
    %pre{:class => "prettyprint", :style => "font-size: 18px; margin-top: 80px"}
      %code
        &nbsp;
        :escaped
          <a4j:jsFunction name="updateName" render="showname">
             <a4j:param name="name" assignTo="\#{functionBean.text}" />
           </a4j:jsFunction>
        &nbsp;
    %ul.notes
      %li Lastly, I'd like to call out the a4j:jsFunction component.
      %li Working with mobile web-apps can involve writing a lot of javascript
      %li The a4j:jsFunction provides a powerful mechanism to interfacing javascript in the client with the JSF backend through the JSF Ajax API
      %li We'll see some sample code making use of this component also in our sample application
%section
  %section
    %h2 Case Study: &ldquo;kitchensink&rdquo; Quickstart
    %img{:src => "assets/images/kitchensink-desktop_scaled.png"}
    %h1.fragment.screen.relative{:style => "border: solid red 4px; top: -440px; left: 170px; width: 336px; height: 125px; line-height: 125px; vertical-align: center;"} 1
    %h1.fragment.screen.relative{:style => "border: solid red 4px; top: -458px; left: 180px; width: 256px; height: 150px; line-height: 150px; vertical-align: center;"} 2
    %h1.fragment.screen.relative{:style => "border: solid red 4px; top: -749px; left: 520px; width: 200px; height: 140px; line-height: 140px; vertical-align: center;"} 3
    %h3.fragment.screen.relative{:style => "border: solid red 4px; top: -628px; left: 180px; width: 352px; height: 58px; line-height: 58px; vertical-align: center;"} 4
    %ul.notes
      %li Let's take a look at a more concrete "real-world" example: here we see the JBoss-as kitchensink sample project.
      %li It's a CRUD application that uses many Java EE APIS's and there corresponding JBoss implementations.
      %li
        We'll take a look at how we "mobilized" this application
        %ul
          %li First using vanilla JSF with custom CSS & Javascript
          %li then we'll introduce RichFaces to simplify the app
          %li lastly we'll look at some experimental components that further simplify things
      %li Let's start with breaking the application down into logically to identify the mobile views we'll require
      %li [ click through the reveal.js fragments ]
  %section
    %h2 kitchensink: &ldquo;Mobilized&rdquo;
    %img.plain.relative{:style => "float:right;", :src => "assets/images/kitchensink-mobile-home_scaled.png"  }
    <!-- demo time -->
    %ul{:style => "margin-top: 180px"}
      %li
        We introduced &ldquo;slidfast&rdquo;:
        %ul
          %li CSS + JavaScript
    %ul.notes
      %li Here's a screenshot of the "mobilized" application.
      %li You can see here the view is single purpose: this is the home page of the mobile application, with nice big clickable menu buttons (even with my fat fingers! )
      %li The custom CSS and javascript resources required to make this work are packaged together into our "slidfast" library
      %li Let's spend a few minutes running the application to get a feel for what it's all about
      %li [ demo the app ]
  %section
    %h2 Mobile compatible with slidfast
    %p{:style => "font-style: italic; margin-top: 200px"}A collection of lightweight CSS and Javascript assets
    %ul.notes
      %li the key thing to keep in mind with slidfast is that it's designed to be light-weight
      %li Slidfast is just what's required to write your mobile app the way you want, without requiring one to adopt a whole framework
      %li This is in contrast with many of the other "heavy-weight" mobile frameworks we mentioned earlier
      %li Slidfast is however AJAX centric, and works best when we write our applications with a single page programming model
%section
  %section
    %h2 &ldquo;Vanilla&rdquo; JSF mobile facelet
    %pre{:class => "prettyprint", :style => "font-size: 8px"}
      %code{:id => "multiple_page_elements"}
        &nbsp;
        :escaped
          <?xml version="1.0" encoding="UTF-8"?>
          <ui:composition template="/WEB-INF/templates/mobile.xhtml"
                          xmlns:ui="http://java.sun.com/jsf/facelets"
                          xmlns:f="http://java.sun.com/jsf/core"
                          xmlns:h="http://java.sun.com/jsf/html">
            <ui:define name="content">
              <h:outputStylesheet name="mobile.css" library="css"/>
              <h:outputScript>
                //initialize mobile RichFaces with slidfast
                slidfast({
                  defaultPageID:'home-page',
                  callback: 'handleHashChange',
                  backButtonID: 'back-button'
                });
              </h:outputScript>
              <div id="browser">
                <header>
                  <div>
                    <div id="back-button" class="hide-button">Home</div>
                    <div id="info-button" class="right-header-button info-link">
                      <a href="#about">i</a>
                    </div>
                    <p>Mobile JSF</p>
                  </div>
                </header>
                <h:form id="mobileForm">
                  <div id="page-container">
                    <div id="home-page" class="page stage-left">
                      <ui:include src="/mobile/home.xhtml"/>
                    </div>
                    <div id="new" class="page stage-right">
                      <ui:include src="/mobile/new.xhtml"/>
                    </div>
                    <div id="list" class="page stage-right">
                      <ui:include src="/mobile/list.xhtml"/>
                    </div>
                    <div id="about" class="page stage-right">
                      <ui:include src="/mobile/about.xhtml"/>
                    </div>
                  </div>
                </h:form>
              </div>
            </ui:define>
          </ui:composition>
        &nbsp;
    .fragment.screen{:data=>{:prettify=>"multiple_page_elements", :prettify_lines=>"2:6"}}
    .fragment.screen{:data=>{:prettify=>"multiple_page_elements", :prettify_lines=>"9:14"}}
    .fragment.screen{:data=>{:prettify=>"multiple_page_elements", :prettify_lines=>"16:16"}}
    .fragment.screen{:data=>{:prettify=>"multiple_page_elements", :prettify_lines=>"17:25"}}
    .fragment.screen{:data=>{:prettify=>"multiple_page_elements", :prettify_lines=>"21:21"}}
    .fragment.screen{:data=>{:prettify=>"multiple_page_elements", :prettify_lines=>"26:41"}}
    %ul.notes
      %li
        Let's look closer at what the mobile facelet page looks like (Don't worry about the font-size, we'll zoom in)
      %li
        This is for a vanilla JSF application + our slidfast CSS and javascript resources (we'll look at RichFaces enhancements to this shortly)
        %ol
          %li We are looking at a facelet composite page that uses a specific mobile template (HTML 5 doctype, slidfast resources)
          %li
            Here we initialize the slidfast library, defining:
            %ul
              %li the initial/default page id,
              %li the name of a callback method we'll see shortly
              %li the id of the button we'll use for backward navigation
          %li the div with id "browser" is styled by slidfast to fill up the entire page
          %li
            the html 5 header tag is used to set the title bar across the top of the page
            %ul
              %li here's where we put the back-button with the id we configured above
          %li notice we navigate using location hashes - we'll see below how slidfast uses the location hash to slide content in and out of the view
          %li here we see a series of div's with css class "page" - this is our single page programming model
      %li this is the juicy part, let's bring this up on a page on it's own
  %section
    %h2 Single-page programming model
    %pre{:class => "prettyprint", :style => "font-size: 18px"}
      %code{:id => "single_page"}
        &nbsp;
        :escaped
          <h:form id="mobileForm">
             <div id="page-container">
                  <div id="home-page" class="page stage-left">
                      <ui:include src="/mobile/home.xhtml"/>
                  </div>
                 <div id="new" class="page stage-right">
                     <ui:include src="/mobile/new.xhtml"/>
                 </div>
                 <div id="list" class="page stage-right">
                     <ui:include src="/mobile/list.xhtml"/>
                 </div>
                 <div id="about" class="page stage-right">
                     <ui:include src="/mobile/about.xhtml"/>
                 </div>
              </div>
          </h:form>
        &nbsp;
    .fragment.screen{:data=>{:prettify=>"single_page", :prettify_lines=>"3:5"}}
    %ul.notes
      %li We can see a number of div elements with the page CSS class, each with an additional stage-* class
      %li These are the page elements that slidfast slides in and out
      %li The page ID activated is the one who's id is set in the location hash
      %li so if I want to activate the "about" page, I have to set the location hash to "about"
      %li Let's take a look at how we can manipulate the location hash to navigate through our pages
  %section
    %h2 Manipulate the location hash
    %p{:style => "width: 90%; margin: 40px auto 10px auto; text-align: left"} Directly, using html links
    %pre{:class => "prettyprint", :style => "font-size: 18px;"}
      %code
        &nbsp;
        :escaped
          <a href="#about">i</a>
        &nbsp;
    %p{:style => "width: 90%; margin: 40px auto 10px auto; text-align: left"} Using javascript
    %pre{:class => "prettyprint", :style => "font-size: 18px;"}
      %code
        &nbsp;
        :escaped
          <rich:panelMenuItem label="Add Member"
                              onclick="location.hash='new'"
                              mode="client" />
        &nbsp;
    %ul.notes
      %li We can set the location hash directly using an html tag
      %li Or we can use a javascript listener on a component to set it
      %li either way, once the location hash is changed, slidfast will initiate the page transition
      %li A big advantage of using th location is hash is it supports backwards navigation - through our custom back button, or via the browser controls
      %li There is (at least!) one significant problem with the previous approach
      %li Can anyone guess what it is?
      %li The approach won't scale - we've front-loaded all our mobile pages
      %li We need an AJAX driven approach that loads pages as required, if we want to scale
  %section
    %h2 Scale w/ dynamic ui:include
    %pre{:class => "prettyprint", :style => "font-size: 18px;"}
      %code{:id => "dynamic_include"}
        &nbsp;
        :escaped
          <div id="page-container">
              <div id="home-page" class="page stage-left">
                  <ui:include src="/mobile/home.xhtml"/>
              </div>
              <div id="app-page" class="page stage-right">
                  <ui:include src="\#{pageBean.page}"/>
              </div>
          </div>
        &nbsp;
    .fragment.screen{:data=>{:prettify=>"dynamic_include", :prettify_lines=>"5:7"}}
    %ul.notes
      %li We can do this by making use of a ui:include tag with a dynamic src.
      %li The trick here is to trigger an ajax update when the location hash changes setting the pageBean property
      %li We'll first look at doing this with Vanilla JSF, leveraging the jsf.ajax javascript API
  %section
    %h2 Update the PageBean - JSF
    %pre{:class => "prettyprint", :style => "font-size: 18px"}
      %code{:id => "handleHashChange"}
        &nbsp;
        :escaped
          <h:inputHidden id="page" value="\#{pageBean.location}" />
          <h:outputScript >
            var handleHashChange = function (page) {
               var hiddenInput = 'mobileForm:page';
               $(document.getElementById(hiddenInput)).val(page);

               var options = {
                  execute: hiddenInput,
                  render : '@form',
                  onevent : function(event) {
                     if(event.status == 'success') {
                        slidfast.core.slideTo('app-page');
                     }
                  }
               }
               jsf.ajax.request(hiddenInput, null, options);
            }
          </h:outputScript>
        &nbsp;
    .fragment{:data=>{:prettify=>"handleHashChange", :prettify_lines=>"1:1"}}
    .fragment{:data=>{:prettify=>"handleHashChange", :prettify_lines=>"3:3"}}
    .fragment{:data=>{:prettify=>"handleHashChange", :prettify_lines=>"4:5"}}
    .fragment{:data=>{:prettify=>"handleHashChange", :prettify_lines=>"7:14"}}
    .fragment{:data=>{:prettify=>"handleHashChange", :prettify_lines=>"16:16"}}
    %ul.notes
      %li
        Here we see the javascript necessary to invoke an ajax update when we change the location hash
        %ol
          %li First we need somewhere to put the location hash so it can be submitted by the ajax request - we do this with a inputHidden element
          %li Here we define the "handleHashChange" listener we registered with slidfast during initialisation - this method will be called whenever slidfast detects a page change
          %li In that listener, we first grab a reference to our hidden input, and update it with the location hash value
          %li
            Next we create an options object we will pass along with the jsf ajax request
            %ul
              %li "execute" and "render are analogous to the same attributes in an f:ajax call
              %li with the onevent callback we trigger the slidfast page transition when the ajax call is successful
          %li Finally we invoke the jsf.ajax method to trigger the ajax call and associated page updates
      %li The value of the location hash gets stored in the "location" property of the pageBean, and is used to specify what page to include in the dynamic ui:include
  %section
    %h2 Update the PageBean - RichFaces 4.2
    %pre{:class => "prettyprint", :style => "font-size: 14pt; margin-top: 20px"}
      %code
        &nbsp;
        :escaped
          <h:outputScript target="head">
          <a4j:jsFunction name="loadPage"
                          render="@form"
                          oncomplete="slidfast.core.slideTo('app-page')">
              <a4j:param name="page" assignTo="\#{pageBean.location}"/>
          </a4j:jsFunction>
        &nbsp;
    %ul.notes
      %li We can simplify this by using the RichFaces a4j:jsFunction component
      %li Notice how we no longer need the hidden input, as the a4j:param component let's us update backing beans directly
      %li We still have the oncomplete callback that invokes the slidfast page transition
      %li This is what we "ship today", if you are writing mobile apps with the current RichFaces release, this is what we provide
      %li Let's take a sneak peak at some work-in-progress in our Sandbox
  %section
    %h2 Update the PageBean - RichFaces Sandbox
    %pre{:class => "prettyprint", :style => "font-size: 18px, :margin-top: 180px"}
      %code
        &nbsp;
        :escaped
          <slidfast:pageChanger id="pageChanger" activePage="\#{pageBean.location}" render="app-page" />
        &nbsp;
    %ul.notes
      %li (The Sandbox is the RichFaces SkunkWorks, where we try out our new ideas and components before landing them into our component set)
      %li here we have a pageChanger that encapsulates the above javascript, and also provides some additional added value
      %li by allowing other components to take over the ajax rendering, in which case the pageChanger component only invokes the slidfast transition
  %section
    %h2 &ldquo;SlidFast&rdquo; JSF mobile facelet
    %pre{:class => "prettyprint", :style => "font-size: 11px"}
      %code{:id => "slidfastComponents_page"}
        &nbsp;
        :escaped
          <?xml version="1.0" encoding="UTF-8"?>
          <ui:composition template="/WEB-INF/templates/mobile.xhtml"
                          xmlns:ui="http://java.sun.com/jsf/facelets"
                          xmlns:h="http://java.sun.com/jsf/html"
                          xmlns:slidfast="http://richfaces.org/slidfast">
              <ui:define name="content">
                  <h:outputStylesheet name="app.css" library="css"/>
                  <h:outputStylesheet name="mobile.css" library="css"/>
                  <div id="browser">
                      <header>
                          <div>
                              <div id="back-button" class="hide-button">Home</div>
                              <div id="info-button" class="right-header-button info-link">
                                  <a href="#about">i</a>
                              </div>
                              <p>Richfaces Mobile</p>
                          </div>
                      </header>
                      <h:form id="mobileForm">
                          <slidfast:pageChanger id="pageChanger" activePage="\#{pageBean.location}" render="app-page" />
                          <slidfast:pageContainer id="pageContainer">
                              <slidfast:page id="home-page" stage="left">
                                  <ui:include src="/mobile/home.xhtml"/>
                              </slidfast:page>
                              <slidfast:page id="app-page" stage="right">
                                  <ui:include src="\#{pageBean.page}"/>
                              </slidfast:page>
                          </slidfast:pageContainer>
                      </h:form>
                  </div>
                 <h:outputStylesheet library="org.richfaces" name="rf-mobile-skin.css" />
              </ui:define>
          </ui:composition>
        &nbsp;
    .fragment{:data=>{:prettify=>"slidfastComponents_page", :prettify_lines=>"20:20"}}
    .fragment{:data=>{:prettify=>"slidfastComponents_page", :prettify_lines=>"21:28"}}
    %ul.notes
      %li Looking at the facelet again as a whole, we can see how the introduction of the slidfast components greatly simplifies the page
      %li The pageChanger component has replaced many lines of javascript
      %li
        The pageContainer and page components have replaced the generic div elements. This offers a number of advantages
        %ul
          %li The page component is a valid target for jsf ajax updates (so we don't need to wrap everything in an h:outputPanel)
          %li The use of CSS classes for imparting behaviour has been replaced with more meaningful attributes, like the "stage" attribute
      %li The result is a page that looks and codes more like JSF, and less like a HTML 5/javascript app
%section
  %section
    %h2 Responsive layout
    %a{:href => "http://bootstrap-richfaces.rhcloud.com", :target =>"demo"}
      %img{:src => "assets/images/richfaces_bootstrap.png"}
    %ul.notes
      %li I'd like to wrap up this presentation with a look at another sandbox effort, where we are creating JSF components out of the twitter bootstrap CSS resources
      %li If you haven't yet heard of the RichFaces bootstrap project, be sure to check it out.
      %li Bootstrap provides a set of cross browser CSS and javascript resources you can use to build modern web applications
      %li I could do a whole presentation on bootstrap components and how they fit with JSF
      %li But the key point I want to raise here is the "Responsive Layout".  Components adjust and resize themselves as the display size changes
      %li let's take a look at a demo of this
      %li [demo the bootstrap responsive layout]
      %li Hopefully you can see hoe building RichFaces applications with these components will lend itself nicely to mobile development
%section
  %h2 The end?
  %h3.fragment{:style => "margin-top: 160px"} The beginning - of your mobile adventure with RichFaces!
  %ul.notes
    %li We've seen how mobile web-apps are a necessity in today's market
    %li and how JSF and RichFaces can be effective means of providing these web apps, particularly if we are already invested in the technology
    %li While RichFaces isn't required for building mobile JSF applications,we can see how the process is simplified by the introduction of javascript encapsulating mobile-specific components
    %li Finally we had a peek into the future, to see how RichFaces is going to further empwer us to build mobile web apps.
%section
  %h2 Credits
  %ul.links
    %li
      %a{:href => "http://www.flickr.com/photos/jdhancock/5845280258/"} http://www.flickr.com/photos/jdhancock/5845280258/
    %li
      %a{:href => "http://leslycorazon.wikispaces.com/file/detail/head-silhouette-with-question-mark.png/319199232"} http://leslycorazon.wikispaces.com/file/detail/head-silhouette-with-question-mark.png/319199232
    %li
      %a{:href => "http://www.linuk.web.id/2010/09/biografi-singkat-linus-torvalds.html"} http://www.linuk.web.id/2010/09/biografi-singkat-linus-torvalds.html
    %li
      %a{:href => "http://en.wikipedia.org/wiki/File:2007Computex_e21Forum-MartinCooper.jpg"}  http://en.wikipedia.org/wiki/File:2007Computex_e21Forum-MartinCooper.jpg
    %li
      %a{:href => "http://gigaom.com/2010/04/12/mary-meeker-mobile-internet-will-soon-overtake-fixed-internet/"} http://gigaom.com/2010/04/12/mary-meeker-mobile-internet-will-soon-overtake-fixed-internet/
    %li
      %a{:href => "https://devcentral.f5.com/weblogs/macvittie/archive/2008/09/10/3604.aspx"}https://devcentral.f5.com/weblogs/macvittie/archive/2008/09/10/3604.aspx
    %li
      %a{:href => "http://openclipart.org/detail/17302/groupe-by-czara1"} http://openclipart.org/detail/17302/groupe-by-czara1
    %li
      %a{:href => "http://openclipart.org/detail/36571/tango-network-workgroup-by-warszawianka"}  http://openclipart.org/detail/36571/tango-network-workgroup-by-warszawianka
    %li
      %a{:href => "http://openclipart.org/detail/22860/money-bag-icon-by-chovynz"} http://openclipart.org/detail/22860/money-bag-icon-by-chovynz
    %li
      %a{:href => "http://openclipart.org/detail/48427/clock-by-palomaironique"} http://openclipart.org/detail/48427/clock-by-palomaironique
    %li
      %a{:href => "http://www.flickr.com/photos/ivyfield/4486938457/"} http://www.flickr.com/photos/ivyfield/4486938457/
    .links.commons
      :plain
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="Creative Commons Licence" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">GOING MOBILE With Your RichFaces Applications</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="www.bleathem.ca/talks/2012-JBW/richfaces-mobile.html" property="cc:attributionName" rel="cc:attributionURL">Brian Leathem</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.<br />Based on a work at <a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/bleathem/talks/tree/master/2012-JBW" rel="dct:source">github.com</a>.<br />Permissions beyond the scope of this license may be available at <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/bleathem/talks/tree/master/2012-JBW" rel="cc:morePermissions">https://github.com/bleathem/talks/tree/master/2012-JBW</a>.
%section
  %h2 Additional Resources
  .left.resources
    %p Source code:
    %ul.links
      %li
        %a{:href => "http://www.jboss.org/jdf/quickstarts/jboss-as-quickstart/kitchensink/"} JBoss-as Kitchensink quickstart
      %li
        %a{:href => "https://github.com/bleathem/quickstart/tree/mobile-jsf"} JBoss-as Kitchensink quickstart | mobile w/ Vanilla JSF
      %li
        %a{:href => "https://github.com/richfaces/as-quickstarts"} JBoss-as Kitchensink quickstart | mobile w/ RichFaces
    %p{:style => "margin-top: 30px"} Articles:
    %ul.links
      %li
        %a{:href => "http://www.html5rocks.com/en/mobile/optimization-and-performance/"} HTML 5 Rocks article
        \- introduces and motivates the slidfast approach
      %li
        %a{:href => "https://community.jboss.org/wiki/RichFacesMobile"} RichFaces Mobile wiki page
        \- all things RichFaces + mobile
      %li
        %a{:href => "https://community.jboss.org/wiki/GettingStartedWithMobileRichFaces"} Getting Started With Mobile RichFaces

%section
  %h2 Stay in the loop
  %ul.links.loop
    %li
      Project website:
      %a{:href => "http://richfaces.org"} http://richfaces.org
    %li
      Twitter:
      %a{:href => "https://twitter.com/#!/richfaces"} https://twitter.com/#!/richfaces
    %li
      Google+:
      %a{:href => "https://plus.google.com/b/115573055688754345457/"} http://richfaces.org
    %li
      RichFaces Forums:
      %a{:href => "https://community.jboss.org/en/richfaces?view=discussions"} https://community.jboss.org/en/richfaces?view=discussions
    %li
      Blog feed:
      %a{:href => "http://planet.jboss.org/feed/richfacesall"} http://planet.jboss.org/feed/richfacesall
    %li
      IRC: #richfaces
  %p{:style => "margin-top: 50px" } Later today:
  %ul.links
    %li
      BOF: What's New in Java Frameworks for Web, Cloud, & Mobile
      %ul
        1:20 pm - 2:20 pm



